<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="hsn_logo.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>HSN Dashboard</title>

    <link href="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.css" rel="stylesheet" />
    <script src="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link rel="stylesheet" href="styles.css">
</head>
<body>

<div id="app" class="container">
    <header class="header">
        <div class="logo">
            <img src="hsn_logo.svg" alt="Hive Sensor Network Logo" class="img_logo"/>
            <h1>Hive Sensor Network</h1>
        </div>
        <nav class="nav">
            <a href="#">About</a>
            <a href="https://auth.eldonbaitandtackle.net/realms/hsn_kc/protocol/openid-connect/auth?client_id=public_client&response_type=code&redirect_uri=https://hsw.eldonbaitandtackle.net/manage">Manage</a>
            <button id="refresh-btn" class="btn-link">Refresh Data</button>
        </nav>
    </header>

    <main class="dashboard-grid">
        <div class="card">
            <div id="map" class="map-wrapper"></div>
            <div id="loading" class="loader hidden">
                <div class="spinner"></div>
            </div>
            <div id="error" class="error-msg hidden"></div>
        </div>

        <div class="charts-col">
            <div class="card chart-card">
                <h3 class="card-title">Network Status</h3>
                <div class="chart-container">
                    <canvas id="doughnutChart"></canvas>
                </div>
            </div>
            <div class="card chart-card">
                <h3 class="card-title">Temperature Variance</h3>
                <div class="chart-container">
                    <canvas id="barChart"></canvas>
                </div>
            </div>
        </div>
    </main>

    <div class="card">
        <div class="table-header">
            <h3>Sensor Telemetry</h3>
            <span class="live-badge">Live</span>
        </div>
        <div class="table-wrapper">
            <table>
                <thead>
                <tr>
                    <th>Location</th>
                    <th>Temp (°F)</th>
                    <th>Avg Neighbor</th>
                    <th>Status</th>
                    <th>Deviation</th>
                </tr>
                </thead>
                <tbody id="data-table-body"></tbody>
            </table>
        </div>
    </div>
</div>

<script>
    const API_ENDPOINT = 'https://hsn.eldonbaitandtackle.net/api/';
    const map = new maplibregl.Map({
        container: 'map',
        style: {
            version: 8,
            sources: {
                'osm': {
                    type: 'raster',
                    tiles: ['https://tile.openstreetmap.org/{z}/{x}/{y}.png'],
                    tileSize: 256,
                    attribution: '&copy; OpenStreetMap Contributors',
                }
            },
            layers: [{ id: 'osm', type: 'raster', source: 'osm' }]
        },
        center: [0, 20],
        zoom: 2
    });

    map.addControl(new maplibregl.NavigationControl(), 'top-right');

    const markers = [];
    let barChartInstance = null;
    let doughnutChartInstance = null;

    function clampLat(lat) {
        return Math.max(-85, Math.min(85, lat));
    }

    function updateConnectionLines(mapData) {
        if (map.getLayer('connections-layer')) map.removeLayer('connections-layer');
        if (map.getSource('connections')) map.removeSource('connections');

        const features = [];
        const nodeMap = new Map(mapData.map(node => [String(node.id), node.location]));
        const processedPairs = new Set();

        mapData.forEach(node => {
            if (!node.neighbors) return;
            const startLoc = node.location;

            node.neighbors.forEach(neighborId => {
                const endLoc = nodeMap.get(String(neighborId));
                const pairId = [node.id, neighborId].sort().join('-');

                if (endLoc && !processedPairs.has(pairId)) {
                    processedPairs.add(pairId);
                    features.push({
                        type: 'Feature',
                        properties: {},
                        geometry: {
                            type: 'LineString',
                            coordinates: [
                                [startLoc[1], clampLat(startLoc[0])],
                                [endLoc[1], clampLat(endLoc[0])]
                            ]
                        }
                    });
                }
            });
        });

        map.addSource('connections', {
            type: 'geojson',
            data: { type: 'FeatureCollection', features }
        });

        map.addLayer({
            id: 'connections-layer',
            type: 'line',
            source: 'connections',
            layout: { 'line-join': 'round', 'line-cap': 'round' },
            paint: {
                'line-color': '#6366f1',
                'line-width': 2,
                'line-opacity': 0.6
            }
        });
    }

    function updateCharts(data) {
        const labels = data.map(d => `ID: ${d.module_id}`);
        const temps = data.map(d => d.self_temp);
        const deviations = data.map(d => d.deviation);
        const devCounts = [0, 0, 0];

        data.forEach(d => {
            if (d.deviation < 0.3) devCounts[0]++;
            else if (d.deviation < 0.7) devCounts[1]++;
            else devCounts[2]++;
        });

        const chartFont = { family: "'Inter', sans-serif", size: 11 };

        const barCtx = document.getElementById('barChart');
        if (barChartInstance) barChartInstance.destroy();
        if (barCtx) {
            barChartInstance = new Chart(barCtx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [
                        { label: 'Temp', data: temps, backgroundColor: '#818cf8', borderRadius: 4 },
                        { label: 'Deviation', data: deviations, backgroundColor: '#94a3b8', borderRadius: 4 }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { legend: { display: false } },
                    scales: {
                        y: { display: false, grid: { display: false } },
                        x: { display: false, grid: { display: false } }
                    }
                }
            });
        }

        const doughCtx = document.getElementById('doughnutChart');
        if (doughnutChartInstance) doughnutChartInstance.destroy();
        if (doughCtx) {
            doughnutChartInstance = new Chart(doughCtx, {
                type: 'doughnut',
                data: {
                    labels: ['Good', 'Warning', 'Critical'],
                    datasets: [{
                        data: devCounts,
                        backgroundColor: ['#34d399', '#fbbf24', '#f87171'],
                        borderWidth: 0
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { legend: { position: 'right', labels: { usePointStyle: true, font: chartFont, boxWidth: 8 } } },
                    cutout: '70%'
                }
            });
        }
    }

    async function apiCall(requestType, payload = {}) {
        const url = new URL(API_ENDPOINT);
        url.searchParams.append('request', requestType);
        for (const [key, value] of Object.entries(payload)) {
            url.searchParams.append(key, String(value));
        }
        const response = await fetch(url.toString());
        if (!response.ok) throw new Error(`HTTP ${response.status}`);
        return await response.json();
    }

    async function fetchAndDisplayData() {
        const loadingEl = document.getElementById('loading');
        const errorEl = document.getElementById('error');
        const tableBody = document.getElementById('data-table-body');

        if (loadingEl) loadingEl.classList.remove('hidden');
        if (errorEl) errorEl.classList.add('hidden');

        try {
            const [mapResponse, heuristicsResponse] = await Promise.all([
                apiCall('get_map'),
                apiCall('get_heuristics')
            ]);

            const mapData = mapResponse.results || [];
            const heuristicsData = heuristicsResponse.results || [];

            updateConnectionLines(mapData);

            const mergedData = heuristicsData.map(h => {
                const node = mapData.find(m => String(m.id) === String(h.module_id));
                const rawLat = node ? node.location[0] : 0;
                const rawLong = node ? node.location[1] : 0;
                return { ...h, lat: clampLat(rawLat), long: rawLong };
            });

            markers.forEach(marker => marker.remove());
            markers.length = 0;
            const bounds = new maplibregl.LngLatBounds();

            mergedData.forEach((sensor) => {
                const popup = new maplibregl.Popup({ offset: 25 }).setHTML(`
                    <div class="popup-content">
                        <h3 class="popup-title">Module ${sensor.module_id}</h3>
                        <div class="popup-detail">
                            Temp: <b>${sensor.self_temp}°F</b><br>
                            Dev: <b>${Number(sensor.deviation).toFixed(4)}</b>
                        </div>
                    </div>
                `);

                const marker = new maplibregl.Marker({ color: sensor.within_range ? '#34d399' : '#f87171' })
                    .setLngLat([sensor.long, sensor.lat])
                    .setPopup(popup)
                    .addTo(map);

                markers.push(marker);
                bounds.extend([sensor.long, sensor.lat]);
            });

            if (markers.length > 0) map.fitBounds(bounds, { padding: 50, maxZoom: 15 });

            if (tableBody) {
                tableBody.innerHTML = '';
                mergedData.forEach((sensor) => {
                    const row = document.createElement('tr');
                    row.innerHTML = `
                        <td class="mono">${sensor.lat.toFixed(4)}, ${sensor.long.toFixed(4)}</td>
                        <td class="val-primary">${sensor.self_temp}</td>
                        <td class="val-secondary">${sensor.avg_neighbor_temp}</td>
                        <td>
                            <span class="status-pill ${sensor.within_range ? 'stable' : 'outlier'}">
                                ${sensor.within_range ? 'Stable' : 'Outlier'}
                            </span>
                        </td>
                        <td class="val-dim">${Number(sensor.deviation).toFixed(5)}</td>
                    `;
                    tableBody.appendChild(row);
                });
            }

            updateCharts(mergedData);

        } catch (error) {
            console.error(error);
            if (errorEl) {
                errorEl.classList.remove('hidden');
                errorEl.textContent = `Error: ${error.message}`;
            }
        } finally {
            if (loadingEl) loadingEl.classList.add('hidden');
        }
    }

    const refreshBtn = document.getElementById('refresh-btn');
    if (refreshBtn) refreshBtn.addEventListener('click', fetchAndDisplayData);

    map.once('load', fetchAndDisplayData);
    setInterval(fetchAndDisplayData, 30000);
</script>
</body>
</html>